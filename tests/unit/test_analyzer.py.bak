"""Unit tests for CoverageImpactAnalyzer"""

import json
from pathlib import Path
from unittest.mock import Mock

import pytest

from pytest_coverage_impact.analyzer import CoverageImpactAnalyzer
from pytest_coverage_impact.call_graph import CallGraph


@pytest.fixture
def temp_project(tmp_path):
    """Create a temporary project structure"""
    project_root = tmp_path / "test_project"
    project_root.mkdir()

    # Create source directory with Python files
    source_dir = project_root / "src"
    source_dir.mkdir()

    # Create a simple Python module
    module_file = source_dir / "module.py"
    module_file.write_text("def hello():\n    return 'world'\n\ndef goodbye():\n    return 'bye'\n")

    # Create coverage.json
    coverage_file = project_root / "coverage.json"
    coverage_data = {
        "files": {
            "src/module.py": {
                "summary": {"covered_lines": 2, "num_statements": 4, "percent_covered": 50.0},
                "excluded_lines": [],
                "missing_lines": [3],
                "executed_lines": [1, 2],
            }
        }
    }
    coverage_file.write_text(json.dumps(coverage_data))

    return project_root, source_dir, coverage_file


def test_analyzer_init_with_source_dir():
    """Test analyzer initialization with explicit source directory"""
    project_root = Path("/project")
    source_dir = Path("/project/src")

    analyzer = CoverageImpactAnalyzer(project_root, source_dir)
    assert analyzer.project_root == project_root.resolve()
    assert analyzer.source_dir == source_dir


def test_analyzer_init_auto_detect_source_dir(tmp_path):
    """Test analyzer initialization with auto-detection of source directory"""
    project_root = tmp_path / "project"
    project_root.mkdir()

    # Create src directory with Python files (no test files)
    src_dir = project_root / "src"
    src_dir.mkdir()
    (src_dir / "module.py").write_text("def test():\n    pass\n")

    # Ensure project_root itself doesn't have Python files that would interfere
    analyzer = CoverageImpactAnalyzer(project_root)
    # Should find src directory since it has Python files and project_root doesn't
    assert analyzer.source_dir in {src_dir, project_root}


def test_analyzer_init_fallback_to_project_root(tmp_path):
    """Test analyzer initialization falls back to project root when no src dir found"""
    project_root = tmp_path / "project"
    project_root.mkdir()

    analyzer = CoverageImpactAnalyzer(project_root)
    assert analyzer.source_dir == project_root


def test_analyze_coverage_file_not_found(tmp_path):
    """Test analyze raises FileNotFoundError when coverage file doesn't exist"""
    project_root = tmp_path / "project"
    project_root.mkdir()

    analyzer = CoverageImpactAnalyzer(project_root)

    with pytest.raises(FileNotFoundError):
        analyzer.analyze()


def test_analyze_no_functions_found(tmp_path):
    """Test analyze raises ValueError when no functions are found"""
    project_root = tmp_path / "project"
    project_root.mkdir()
    source_dir = project_root / "src"
    source_dir.mkdir()

    # Create empty coverage.json
    coverage_file = project_root / "coverage.json"
    coverage_file.write_text(json.dumps({"files": {}}))

    analyzer = CoverageImpactAnalyzer(project_root, source_dir)

    with pytest.raises(ValueError, match="No functions found"):
        analyzer.analyze(coverage_file)


def test_analyze_success(temp_project):  # pylint: disable=redefined-outer-name
    """Test successful analysis"""
    project_root, source_dir, coverage_file = temp_project

    analyzer = CoverageImpactAnalyzer(project_root, source_dir)
    results = analyzer.analyze(coverage_file)

    assert "call_graph" in results
    assert "impact_scores" in results
    assert "complexity_scores" in results
    assert "confidence_scores" in results
    assert "prioritized" in results

    assert isinstance(results["call_graph"], CallGraph)
    assert isinstance(results["impact_scores"], list)
    assert isinstance(results["complexity_scores"], dict)
    assert isinstance(results["confidence_scores"], dict)
    assert isinstance(results["prioritized"], list)


def test_analyze_with_model_path(temp_project, tmp_path):  # pylint: disable=redefined-outer-name
    """Test analysis with explicit model path"""
    project_root, source_dir, coverage_file = temp_project

    # Create a mock model file
    model_file = tmp_path / "model.pkl"
    model_file.write_bytes(b"mock model")

    analyzer = CoverageImpactAnalyzer(project_root, source_dir)
    results = analyzer.analyze(coverage_file, model_path=model_file)

    # Should still complete even if model can't be loaded
    assert "call_graph" in results
    assert "prioritized" in results


def test_get_model_path_with_cli_path(tmp_path):
    """Test get_model_path with CLI provided path"""
    project_root = tmp_path / "project"
    project_root.mkdir()
    model_file = project_root / "custom_model.pkl"
    model_file.write_bytes(b"model data")

    analyzer = CoverageImpactAnalyzer(project_root)
    result = analyzer.get_model_path(str(model_file))

    assert result == model_file.resolve()


def test_get_model_path_without_cli_path(tmp_path, monkeypatch):
    """Test get_model_path without CLI path (uses defaults)"""
    project_root = tmp_path / "project"
    project_root.mkdir()

    analyzer = CoverageImpactAnalyzer(project_root)

    # Mock environment variable
    monkeypatch.delenv("PYTEST_COVERAGE_IMPACT_MODEL_PATH", raising=False)

    result = analyzer.get_model_path()

    # Should return default bundled model if it exists, or None
    # We can't reliably test this without the actual bundled model
    assert result is None or isinstance(result, Path)


def test_get_model_path_from_env_var(tmp_path, monkeypatch):
    """Test get_model_path uses environment variable"""
    project_root = tmp_path / "project"
    project_root.mkdir()
    model_file = project_root / "env_model.pkl"
    model_file.write_bytes(b"env model")

    analyzer = CoverageImpactAnalyzer(project_root)
    monkeypatch.setenv("PYTEST_COVERAGE_IMPACT_MODEL_PATH", str(model_file))

    result = analyzer.get_model_path()
    assert result == model_file.resolve()


def test_estimate_complexities_no_model(temp_project):  # pylint: disable=redefined-outer-name
    """Test _estimate_complexities without a model"""
    project_root, source_dir, coverage_file = temp_project

    analyzer = CoverageImpactAnalyzer(project_root, source_dir)
    results = analyzer.analyze(coverage_file)

    impact_scores = results["impact_scores"]
    # Pass a nonexistent model path to ensure no model is used
    nonexistent_path = project_root / "nonexistent_model.pkl"
    # JUSTIFICATION: White-box testing of private component internals required for coverage
    # pylint: disable=protected-access,clean-arch-visibility,private-method-test
    complexity_scores, confidence_scores = analyzer._estimate_complexities(impact_scores, model_path=nonexistent_path)

    # Should return empty dicts when no model is available
    assert not complexity_scores
    assert not confidence_scores


def test_estimate_function_complexity_file_not_found(temp_project):  # pylint: disable=redefined-outer-name
    """Test _estimate_function_complexity with nonexistent file"""
    project_root, source_dir, _ = temp_project

    analyzer = CoverageImpactAnalyzer(project_root, source_dir)
    mock_estimator = Mock()

    # JUSTIFICATION: White-box testing of private component internals required for coverage
    # pylint: disable=protected-access,clean-arch-visibility,private-method-test
    result = analyzer._estimate_function_complexity(mock_estimator, Path("/nonexistent/file.py"), 1, "test::function")

    assert result == (None, None, None)


def test_estimate_function_complexity_function_not_found(temp_project):  # pylint: disable=redefined-outer-name
    """Test _estimate_function_complexity when function doesn't exist at line"""
    project_root, source_dir, _ = temp_project

    module_file = source_dir / "module.py"
    analyzer = CoverageImpactAnalyzer(project_root, source_dir)
    mock_estimator = Mock()

    # Try to find function at line 99 (doesn't exist)
    # JUSTIFICATION: White-box testing of private component internals required for coverage
    # pylint: disable=protected-access,private-method-test,clean-arch-visibility
    result = analyzer._estimate_function_complexity(mock_estimator, module_file, 99, "test::function")

    assert result == (None, None, None)


def test_find_source_directory_priority_order(tmp_path):
    """Test source directory detection uses correct priority order"""
    project_root = tmp_path / "myproject"
    project_root.mkdir()

    # Create multiple possible source directories
    nested_dir = project_root / "myproject"
    nested_dir.mkdir()
    (nested_dir / "code.py").write_text("def test():\n    pass\n")

    src_dir = project_root / "src"
    src_dir.mkdir()
    (src_dir / "code.py").write_text("def test():\n    pass\n")

    analyzer = CoverageImpactAnalyzer(project_root)
    # Should prefer nested directory (project_name/project_name) over src, or find one of them
    assert analyzer.source_dir in {nested_dir, src_dir, project_root}
